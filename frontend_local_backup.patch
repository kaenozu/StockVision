diff --cc frontend/src/App.tsx
index 0440c89,14664b4..0000000
--- a/frontend/src/App.tsx
+++ b/frontend/src/App.tsx
@@@ -1,138 -1,164 +1,138 @@@
  /**
 - * Main App Component
 - * 
 - * Root application component with routing, error boundaries,
 - * and global state management.
 + * Main App Component - 完全版
   */
  
 -import React, { Suspense } from 'react'
 -import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
 -import Layout from './components/layout/Layout'
 -import { LoadingLayout, ErrorBoundaryLayout } from './components/layout/Layout'
 -import HomePage from './pages/HomePage'
 -import SimplifiedHomePage from './pages/SimplifiedHomePage'
 -import StockDetailPage from './pages/StockDetailPage'
 -import WatchlistPage from './pages/WatchlistPage'
 -import SearchPage from './pages/SearchPage'
 +import React from 'react'
 +import { BrowserRouter as Router, Routes, Route, Link } from 'react-router-dom'
 +import { useTheme } from './contexts/ThemeContext'
 +
- // Import all original pages
++// Import all original pages  
 +import SimplifiedHomePage from './pages/StockDashboardInline'
 +import StockDetail from './pages/StockDetail'
  import SettingsPage from './pages/SettingsPage'
 -import DemoPage from './pages/DemoPage'
  import RecommendedStocksPage from './pages/RecommendedStocksPage'
  import TradingRecommendationsPage from './pages/TradingRecommendationsPage'
 -import TestPage from './pages/TestPage'
 -
 -// Error Boundary Component
 -class ErrorBoundary extends React.Component<
 -  { children: React.ReactNode },
 -  { hasError: boolean; error: Error | null }
 -> {
 -  constructor(props: { children: React.ReactNode }) {
 -    super(props)
 -    this.state = { hasError: false, error: null }
 -  }
 -
 -  static getDerivedStateFromError(error: Error) {
 -    return { hasError: true, error }
 -  }
 -
 -  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
 -    console.error('React Error Boundary caught an error:', error, errorInfo)
 -  }
 -
 -  render() {
 -    if (this.state.hasError && this.state.error) {
 -      return (
 -        <ErrorBoundaryLayout
 -          error={this.state.error}
 -          onRetry={() => this.setState({ hasError: false, error: null })}
 -        />
 -      )
 -    }
  
 -    return this.props.children
 -  }
 -}
 +// プロフェッショナルなヘッダー
 +function Header() {
 +  const { actualTheme, toggleTheme } = useTheme()
 +  
 +  return (
 +    <header className="bg-white dark:bg-gray-900 shadow-lg border-b border-gray-200 dark:border-gray-700">
 +      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
 +        <div className="flex justify-between items-center h-16">
 +          {/* ロゴとタイトル */}
 +          <div className="flex items-center">
 +            <div className="flex-shrink-0 flex items-center">
 +              <div className="w-10 h-10 bg-gradient-to-r from-blue-500 to-purple-600 rounded-lg flex items-center justify-center mr-3">
 +                <span className="text-white font-bold text-lg">SV</span>
 +              </div>
 +              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
 +                StockVision
 +              </h1>
 +            </div>
 +          </div>
  
 -// Lazy load components for code splitting
 -const AboutPage = React.lazy(() => 
 -  import('./pages/AboutPage').catch(() => ({ 
 -    default: () => (
 -      <div className="text-center py-12">
 -        <h1 className="text-2xl font-bold mb-4">About</h1>
 -        <p>株価チェッカーについてのページは準備中です。</p>
 -      </div>
 -    )
 -  }))
 -)
 +          {/* ナビゲーション */}
 +          <nav className="hidden md:flex space-x-8">
 +            <Link
 +              to="/"
 +              className="px-3 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white transition-colors"
 +            >
 +              ダッシュボード
 +            </Link>
 +            <Link
 +              to="/recommended-stocks"
 +              className="px-3 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white transition-colors"
 +            >
 +              おすすめ銘柄
 +            </Link>
 +            <Link
 +              to="/trading-recommendations"
 +              className="px-3 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white transition-colors"
 +            >
 +              投資判断
 +            </Link>
 +            <Link
 +              to="/settings"
 +              className="px-3 py-2 rounded-md text-sm font-medium text-gray-600 hover:text-gray-900 dark:text-gray-300 dark:hover:text-white transition-colors"
 +            >
 +              設定
 +            </Link>
 +          </nav>
  
 -const NotFoundPage = React.lazy(() => 
 -  Promise.resolve({
 -    default: () => (
 -      <div className="text-center py-12">
 -        <div className="text-6xl mb-6">🔍</div>
 -        <h1 className="text-3xl font-bold text-gray-900 mb-4">
 -          ページが見つかりません
 -        </h1>
 -        <p className="text-gray-600 mb-8">
 -          お探しのページは存在しないか、移動した可能性があります。
 -        </p>
 -        <div className="space-x-4">
 -          <button 
 -            onClick={() => window.history.back()}
 -            className="px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white rounded-lg font-medium transition-colors"
 -          >
 -            戻る
 -          </button>
 -          <button 
 -            onClick={() => window.location.href = '/'}
 -            className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors"
 -          >
 -            ホームに戻る
 -          </button>
 +          {/* テーマ切り替えボタン */}
 +          <div className="flex items-center">
 +            <button
 +              onClick={toggleTheme}
 +              className="p-2 rounded-lg bg-gray-100 dark:bg-gray-800 hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors"
 +              aria-label="テーマを切り替え"
 +            >
 +              {actualTheme === 'dark' ? '🌙' : '☀️'}
 +            </button>
 +          </div>
          </div>
        </div>
 -    )
 -  })
 -)
 +    </header>
 +  )
 +}
  
 -/**
 - * Main App Component
 - */
 -function App() {
 -  const handleGlobalSearch = (stockCode: string, useRealData: boolean) => {
 -    // This function is called from header search
 -    // Navigation is handled by the header component itself
 -    console.log('Global search:', stockCode, useRealData)
 -  }
 +// メインレイアウト
 +function Layout({ children }: { children: React.ReactNode }) {
 +  return (
 +    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors">
 +      <Header />
 +      <main>
 +        {children}
 +      </main>
 +    </div>
 +  )
 +}
  
 +function App() {
    return (
 -    <ErrorBoundary>
 -      <Router>
 -        <div className="App">
 -          <Routes>
 -            {/* Demo page - standalone without layout */}
 -            <Route path="/demo" element={<DemoPage />} />
 -            
 -            <Route path="/" element={<Layout onSearch={handleGlobalSearch} />}>
 -              {/* Main Routes */}
 -              <Route index element={<SimplifiedHomePage />} />
 -              <Route path="stock/:stockCode" element={<StockDetailPage />} />
 -              <Route path="stocks/:stockId/detail" element={<StockDetailPage />} />
 -              <Route path="watchlist" element={<WatchlistPage />} />
 -              <Route path="search" element={<SearchPage />} />
 -              <Route path="settings" element={<SettingsPage />} />
 -              
 -              {/* Legacy route for complex home page */}
 -              <Route path="home-advanced" element={<HomePage />} />
 -              
 -              {/* New Feature Routes */}
 -              <Route path="recommended-stocks" element={<RecommendedStocksPage />} />
 -              <Route path="trading-recommendations" element={<TradingRecommendationsPage />} />
 -              
 -              {/* Test Page for debugging */}
 -              {import.meta.env.DEV && <Route path="test" element={<TestPage />} />}
 -              
 -              {/* Lazy Loaded Routes */}
 -              <Route 
 -                path="about" 
 -                element={
 -                  <Suspense fallback={<LoadingLayout message="ページを読み込み中..." />}>
 -                    <AboutPage />
 -                  </Suspense>
 -                } 
 -              />
 -              
 -              {/* Redirect legacy routes */}
 -              <Route path="stocks/:stockCode" element={<Navigate to="/stock/:stockCode" replace />} />
 -              <Route path="portfolio" element={<Navigate to="/watchlist" replace />} />
 -              
 -              {/* 404 Page */}
 -              <Route 
 -                path="*" 
 -                element={
 -                  <Suspense fallback={<LoadingLayout />}>
 -                    <NotFoundPage />
 -                  </Suspense>
 -                } 
 -              />
 -            </Route>
 -          </Routes>
 -        </div>
 -      </Router>
 -    </ErrorBoundary>
 +    <Router>
 +      <div className="App">
 +        <Routes>
 +          <Route path="/" element={<SimplifiedHomePage />} />
 +          <Route path="/stock/:stockCode" element={<StockDetail />} />
 +          <Route path="/recommended-stocks" element={
 +            <Layout>
 +              <RecommendedStocksPage />
 +            </Layout>
 +          } />
 +          <Route path="/trading-recommendations" element={
 +            <Layout>
 +              <TradingRecommendationsPage />
 +            </Layout>
 +          } />
 +          <Route path="/settings" element={
 +            <Layout>
 +              <SettingsPage />
 +            </Layout>
 +          } />
 +          <Route path="*" element={
 +            <Layout>
 +              <div className="text-center py-12">
 +                <div className="text-6xl mb-6">🔍</div>
 +                <h1 className="text-3xl font-bold text-gray-900 dark:text-white mb-4">
 +                  ページが見つかりません
 +                </h1>
 +                <p className="text-gray-600 dark:text-gray-400 mb-8">
 +                  お探しのページは存在しないか、移動した可能性があります。
 +                </p>
 +                <Link
 +                  to="/"
 +                  className="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg font-medium transition-colors"
 +                >
 +                  ホームに戻る
 +                </Link>
 +              </div>
 +            </Layout>
 +          } />
 +        </Routes>
 +      </div>
 +    </Router>
    )
  }
  
diff --cc frontend/src/services/stockApi.ts
index 534b012,20c7204..0000000
--- a/frontend/src/services/stockApi.ts
+++ b/frontend/src/services/stockApi.ts
@@@ -11,150 -19,787 +11,754 @@@ import 
    PriceHistoryItem,
    WatchlistItemAPI,
    AddWatchlistRequest,
 -  APIError,
 -  isValidStockCode,
 -  isStockData,
 -  isCurrentPriceResponse,
 -  isPriceHistoryItem,
 -  isApiError,
 -  isWatchlistItemAPI,
 -  DEFAULT_DAYS_HISTORY,
 -  MAX_DAYS_HISTORY,
 -  MIN_DAYS_HISTORY
 +  APIError
  } from '../types/stock'
 -import { stockDataCache, priceHistoryCache, recommendationCache } from './cacheService'
 -import { errorLogger, ErrorCategory, ErrorSeverity, logNetworkError, logValidationError, logCacheError } from './errorLogger'
 -import { generateCacheKey } from '../utils/cache''
  
  /**
 - * Stock API Configuration
 + * Mock Stock API Implementation
   */
++<<<<<<< HEAD
 +export const stockApi = {
 +  /**
 +   * Get current price for a stock
 +   */
 +  async getCurrentPrice(stockCode: string): Promise<CurrentPriceResponse> {
 +    // Simulate API delay
 +    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000))
 +    
 +    // Return mock data
 +    const basePrice = 1000 + Math.random() * 10000
 +    const change = (Math.random() - 0.5) * 200
 +    
 +    return {
 +      current_price: Math.round(basePrice),
 +      previous_close: Math.round(basePrice - change),
 +      price_change: Math.round(change),
 +      price_change_pct: Number(((change / (basePrice - change)) * 100).toFixed(2)),
 +      timestamp: new Date().toISOString()
++=======
+ interface StockApiConfig {
+   baseURL: string
+   timeout: number
+   retries: number
+   retryDelay: number
+ }
+ 
+ /**
+  * Default configuration for the API client
+  */
+ const DEFAULT_CONFIG: StockApiConfig = {
+   baseURL: import.meta.env.VITE_API_BASE_URL || (process.env.NODE_ENV === 'production' 
+     ? '/api' 
+     : process.env.NODE_ENV === 'test' 
+     ? 'http://localhost:8001/api' 
+     : 'http://localhost:8080/api'),
+   timeout: 10000, // 10 seconds
+   retries: 3,
+   retryDelay: 1000 // 1 second
+ }
+ 
+ /**
+  * Custom error class for API errors
+  */
+ export class StockApiError extends Error {
+   constructor(
+     public status: number,
+     public message: string,
+     public type?: string,
+     public details?: any
+   ) {
+     super(message)
+     this.name = 'StockApiError'
+   }
+ }
+ 
+ /**
+  * Custom error class for validation errors
+  */
+ export class ValidationError extends Error {
+   constructor(message: string, public field?: string) {
+     super(message)
+     this.name = 'ValidationError'
+   }
+ }
+ 
+ /**
+  * Stock API Client Class
+  */
+ export class StockApiClient {
+   private client: AxiosInstance
+   private config: StockApiConfig
+ 
+   constructor(config: Partial<StockApiConfig> = {}) {
+     this.config = { ...DEFAULT_CONFIG, ...config }
+     
+     // Create axios instance with configuration
+     this.client = axios.create({
+       baseURL: this.config.baseURL,
+       timeout: this.config.timeout,
+       headers: {
+         'Content-Type': 'application/json',
+         'Accept': 'application/json'
+       }
+     })
+ 
+     // Setup request interceptor for logging in development
+     this.client.interceptors.request.use(
+       (config) => {
+         if (process.env.NODE_ENV === 'development') {
+           const fullUrl = `${config.baseURL}${config.url}`
+           console.log(`[StockAPI] ${config.method?.toUpperCase()} ${fullUrl}`)
+         }
+         return config
+       },
+       (error) => Promise.reject(error)
+     )
+ 
+     // Setup response interceptor
+     this.client.interceptors.response.use(
+       (response) => {
+         if (process.env.NODE_ENV === 'development') {
+           console.log(`[StockAPI] Response ${response.status} for ${response.config.url}`)
+         }
+         return response
+       },
+       (error) => this.handleHttpError(error)
+     )
+   }
+ 
+   /**
+    * Retry mechanism with exponential backoff
+    */
+   private async retryRequest<T>(
+     requestFn: () => Promise<T>,
+     maxRetries: number = this.config.retries,
+     baseDelay: number = this.config.retryDelay
+   ): Promise<T> {
+     let lastError: any
+ 
+     for (let attempt = 0; attempt <= maxRetries; attempt++) {
+       try {
+         return await requestFn()
+       } catch (error) {
+         lastError = error
+         
+         // Don't retry on client errors (4xx) or if max retries reached
+         if (attempt >= maxRetries || this.isClientError(error)) {
+           break
+         }
+ 
+         // Exponential backoff with jitter
+         const delay = baseDelay * Math.pow(2, attempt) + Math.random() * 1000
+         await this.sleep(delay)
+         
+         if (process.env.NODE_ENV === 'development') {
+           console.log(`[StockAPI] Retry attempt ${attempt + 1}/${maxRetries} after ${delay}ms`)
+         }
+       }
+     }
+ 
+     throw lastError
+   }
+ 
+   /**
+    * Check if error is a client error (4xx) that shouldn't be retried
+    */
+   private isClientError(error: any): boolean {
+     return error instanceof StockApiError && error.status >= 400 && error.status < 500
+   }
+ 
+   /**
+    * Sleep utility for retry delays
+    */
+   private sleep(ms: number): Promise<void> {
+     return new Promise(resolve => setTimeout(resolve, ms))
+   }
+ 
+   /**
+    * Handle HTTP errors and transform them to StockApiError
+    */
+   private handleHttpError(error: AxiosError): Promise<never> {
+     // Log detailed error information in development mode
+     if (process.env.NODE_ENV === 'development') {
+       console.error('[StockAPI] HTTP Error Details:', {
+         message: error.message,
+         code: error.code,
+         config: {
+           url: error.config?.url,
+           baseURL: error.config?.baseURL,
+           method: error.config?.method,
+           fullURL: `${error.config?.baseURL || ''}${error.config?.url || ''}`
+         },
+         request: error.request ? 'Request was made' : 'Request was not made',
+         response: error.response ? {
+           status: error.response.status,
+           statusText: error.response.statusText,
+           data: error.response.data
+         } : 'No response received'
+       })
+     }
+     
+     const stockApiError = (() => {
+       if (error.response) {
+         // Server responded with error status
+         const { status, data } = error.response
+         if (isApiError(data)) {
+           const apiError = data.error;
+           return new StockApiError(
+             status,
+             apiError.message || `HTTP ${status} Error`,
+             apiError.type,
+             apiError.details
+           )
+         }
+         return new StockApiError(status, `HTTP ${status} Error`)
+       } else if (error.request) {
+         // Request was made but no response received
+         return new StockApiError(0, 'Network Error', 'network', 'No response from server')
+       } else {
+         // Something else happened
+         return new StockApiError(0, error.message || 'Unknown Error', 'unknown')
+       }
+     })()
+ 
+     // Log the error with context
+     logNetworkError(stockApiError, {
+       url: error.config?.url,
+       method: error.config?.method?.toUpperCase(),
+       status: error.response?.status,
+       function: 'handleHttpError'
+     })
+ 
+     throw stockApiError
+   }
+ 
+   /**
+    * Validate stock code format
+    */
+   private validateStockCode(stockCode: string): void {
+     if (!isValidStockCode(stockCode)) {
+       const error = new ValidationError('Invalid stock code format. Must be 4 digits.', 'stock_code')
+       logValidationError(error.message, {
+         field: 'stock_code',
+         value: stockCode,
+         function: 'validateStockCode'
+       })
+       throw error
++>>>>>>> origin/main
      }
 -  }
 +  },
  
    /**
 -   * Validate days parameter
 +   * Get stock data by code
     */
 -  private validateDays(days: number): void {
 -    if (days < MIN_DAYS_HISTORY || days > MAX_DAYS_HISTORY) {
 -      const error = new ValidationError(
 -        `Invalid days parameter. Must be between ${MIN_DAYS_HISTORY} and ${MAX_DAYS_HISTORY}.`,
 -        'days'
 -      )
 -      logValidationError(error.message, {
 -        field: 'days',
 -        value: days,
 -        function: 'validateDays'
 -      })
 -      throw error
 +  async getStockData(stockCode: string): Promise<StockData> {
 +    const priceData = await this.getCurrentPrice(stockCode)
 +    
 +    const companyNames: Record<string, string> = {
 +      '7203': 'トヨタ自動車',
 +      '6758': 'ソニーグループ',  
 +      '9984': 'ソフトバンクグループ',
 +      '6861': 'キーエンス',
 +      '7974': '任天堂',
 +      '9983': 'ファーストリテイリング',
 +      '4755': '楽天グループ',
 +      '6902': 'デンソー'
      }
 -  }
 +    
 +    return {
 +      stock_code: stockCode,
 +      company_name: companyNames[stockCode] || `株式会社 ${stockCode}`,
 +      current_price: priceData.current_price,
 +      previous_close: priceData.previous_close,
 +      price_change: priceData.price_change,
 +      percentage_change: priceData.price_change_pct,
 +      volume: Math.floor(Math.random() * 10000000),
 +      market_cap: priceData.current_price * 1000000000,
 +      updated_at: priceData.timestamp
 +    }
 +  },
  
    /**
 -   * GET /stocks/{code} - Get basic stock information
 +   * Get price history for a stock
     */
++<<<<<<< HEAD
 +  async getPriceHistory(stockCode: string, days: number = 30): Promise<PriceHistoryItem[]> {
 +    await new Promise(resolve => setTimeout(resolve, 500))
 +    
 +    const history: PriceHistoryItem[] = []
 +    const basePrice = 1000 + Math.random() * 10000
 +    
 +    for (let i = days - 1; i >= 0; i--) {
 +      const date = new Date()
 +      date.setDate(date.getDate() - i)
 +      
 +      const price = basePrice + (Math.random() - 0.5) * 500
 +      
 +      history.push({
 +        date: date.toISOString().split('T')[0],
 +        open_price: Math.round(price * 0.99),
 +        close_price: Math.round(price),
 +        high_price: Math.round(price * 1.02),
 +        low_price: Math.round(price * 0.98),
 +        volume: Math.floor(Math.random() * 1000000)
 +      })
 +    }
 +    
 +    return history
 +  },
 +
 +  /**
 +   * Get watchlist items
++=======
+   async getStockData(stockCode: string, useRealData = true): Promise<StockData> {
+     this.validateStockCode(stockCode)
+ 
+     // Check cache first
+     const cacheKey = generateCacheKey('stock', { stockCode, useRealData });
+     try {
+       const cached = stockDataCache.get<StockData>(cacheKey)
+       if (cached) {
+         console.log(`[StockAPI] Using cached data for ${stockCode}`)
+         return cached
+       }
+     } catch (error) {
+       logCacheError(error as Error, {
+         operation: 'get',
+         key: cacheKey,
+         function: 'getStockData'
+       })
+     }
+ 
+     const params: Record<string, any> = {}
+     if (useRealData) {
+       params.use_real_data = true
+     }
+ 
+     const stockData = await this.retryRequest(async () => {
+       const response = await this.client.get<StockData>(
+         `/stocks/${stockCode}`,
+         { params }
+       )
+ 
+       const adjustedData = this.adjustPriceToRealistic(response.data)
+ 
+       // Validate response data structure
+       if (!isStockData(adjustedData)) {
+         throw new ValidationError('Invalid data type in StockData response')
+       }
+ 
+       return adjustedData
+     })
+ 
+     // Cache the result
+     try {
+       stockDataCache.set(cacheKey, stockData)
+     } catch (error) {
+       logCacheError(error as Error, {
+         operation: 'set',
+         key: cacheKey,
+         function: 'getStockData'
+       })
+     }
+ 
+     return stockData
+   }
+ 
+   /**
+    * GET /stocks/{code}/current - Get current price information
+    */
+   async getCurrentPrice(stockCode: string, useRealData = true): Promise<CurrentPriceResponse> {
+     this.validateStockCode(stockCode)
+ 
+     const params: Record<string, unknown> = {}
+     if (useRealData) {
+       params.use_real_data = true
+     }
+ 
+     return await this.retryRequest(async () => {
+       const response = await this.client.get<CurrentPriceResponse>(
+         `/stocks/${stockCode}/current`,
+         { params }
+       )
+ 
+       const currentPrice = this.adjustCurrentPriceToRealistic(response.data)
+ 
+       // Validate response data structure
+       if (!isCurrentPriceResponse(currentPrice)) {
+         throw new ValidationError('Invalid data type in CurrentPriceResponse')
+       }
+ 
+       return currentPrice
+     })
+   }
+ 
+   /**
+    * GET /stocks/{code}/history - Get price history
+    */
+   async getPriceHistory(
+     stockCode: string, 
+     days: number = DEFAULT_DAYS_HISTORY,
+     useRealData = true
+   ): Promise<PriceHistoryItem[]> {
+     this.validateStockCode(stockCode)
+     this.validateDays(days)
+ 
+     // Check cache first
+     const cacheKey = generateCacheKey('history', { stockCode, days, useRealData });
+     const cached = priceHistoryCache.get<PriceHistoryItem[]>(cacheKey)
+     if (cached) {
+       console.log(`[StockAPI] Using cached price history for ${stockCode}`)
+       return cached
+     }
+ 
+     const params: Record<string, any> = { days }
+     if (useRealData) {
+       params.use_real_data = true
+     }
+ 
+     const response = await this.client.get<PriceHistoryItem[]>(
+       `/stocks/${stockCode}/history`,
+       { params }
+     )
+ 
+     const history = response.data
+ 
+     // Validate response data structure
+     if (!Array.isArray(history)) {
+       throw new ValidationError('Invalid data type: expected array in PriceHistory response')
+     }
+ 
+     // Validate each history item and OHLC relationships
+     for (const item of history) {
+       if (!isPriceHistoryItem(item)) {
+         throw new ValidationError('Invalid data type in PriceHistoryItem')
+       }
+ 
+       // Validate OHLC data relationships
+       if (item.high < Math.max(item.open, item.close)) {
+         throw new ValidationError('Invalid OHLC data: high price is less than open/close')
+       }
+       if (item.low > Math.min(item.open, item.close)) {
+         throw new ValidationError('Invalid OHLC data: low price is greater than open/close')
+       }
+       if (item.volume < 0) {
+         throw new ValidationError('Invalid volume data: volume cannot be negative')
+       }
+     }
+ 
+     // Sort by date descending (most recent first)
+     const sortedHistory = history.sort((a, b) => {
+       return new Date(b.date).getTime() - new Date(a.date).getTime()
+     })
+ 
+     // Cache the result
+     priceHistoryCache.set(cacheKey, sortedHistory)
+ 
+     return sortedHistory
+   }
+ 
+   /**
+    * GET /watchlist - Get user's watchlist
++>>>>>>> origin/main
     */
    async getWatchlist(): Promise<WatchlistItemAPI[]> {
 -    const response = await this.client.get<WatchlistItemAPI[]>('/watchlist')
 +    await new Promise(resolve => setTimeout(resolve, 300))
      
 -    const watchlist = response.data
 -
 -    // Validate response data structure
 -    if (!Array.isArray(watchlist)) {
 -      throw new ValidationError('Invalid data type: expected array in watchlist response')
 -    }
 -
 -    // Validate each watchlist item
 -    for (const item of watchlist) {
 -      if (!isWatchlistItemAPI(item)) {
 -        throw new ValidationError('Invalid data type in WatchlistItemAPI')
 +    // Return mock watchlist
 +    return [
 +      {
 +        id: 1,
 +        stock_code: '7203',
 +        user_notes: 'トヨタ自動車 - EV投資に注目'
 +      },
 +      {
 +        id: 2, 
 +        stock_code: '6758',
 +        user_notes: 'ソニーグループ - エンタメ事業好調'
        }
 -    }
 -
 -    return watchlist
 -  }
 +    ]
 +  },
  
    /**
 -   * POST /watchlist - Add stock to watchlist
 +   * Add to watchlist
     */
    async addToWatchlist(request: AddWatchlistRequest): Promise<WatchlistItemAPI> {
 -    // Validate request data
 -    this.validateStockCode(request.stock_code)
 +    await new Promise(resolve => setTimeout(resolve, 300))
      
 -    if (request.alert_price !== undefined && request.alert_price !== null && request.alert_price <= 0) {
 -      throw new ValidationError('Invalid alert price: must be greater than 0', 'alert_price')
 -    }
 -
 -    // Validate request data types
 -    if (typeof request.stock_code !== 'string') {
 -      throw new ValidationError('Invalid request data type: stock_code must be string')
 -    }
 -    if (request.alert_price !== undefined && request.alert_price !== null && typeof request.alert_price !== 'number') {
 -      throw new ValidationError('Invalid request data type: alert_price must be number or null')
 -    }
 -
 -    const response = await this.client.post<WatchlistItemAPI>(
 -      '/watchlist',
 -      request
 -    )
 -
 -    const watchlistItem = response.data
 -
 -    // Validate response data structure
 -    if (!isWatchlistItemAPI(watchlistItem)) {
 -      throw new ValidationError('Invalid data type in WatchlistItemAPI response')
 +    return {
 +      id: Math.floor(Math.random() * 1000),
 +      stock_code: request.stock_code,
 +      user_notes: request.user_notes || ''
      }
 -
 -    return watchlistItem
 -  }
 +  },
  
    /**
 -   * DELETE /watchlist/{stock_code} - Remove stock from watchlist
 +   * Remove from watchlist
     */
 -  async removeFromWatchlist(stockCode: string): Promise<{ message: string }> {
 -    this.validateStockCode(stockCode)
 -
 -    const response = await this.client.delete<{ message: string }>(
 -      `/watchlist/${stockCode}`
 -    )
 -
 -    return response.data
 -  }
 +  async removeFromWatchlist(itemId: number): Promise<void> {
 +    await new Promise(resolve => setTimeout(resolve, 300))
 +    // Mock implementation - just wait
 +  },
  
    /**
++<<<<<<< HEAD
 +   * Clear all caches (mock implementation)
++=======
+    * GET /stocks/{code}/enhanced - Get enhanced stock information with predictions
+    */
+   async getEnhancedStockInfo(stockCode: string, useRealData = true): Promise<any> {
+     this.validateStockCode(stockCode)
+ 
+     const params: Record<string, any> = {}
+     if (useRealData !== null) {
+       params.use_real_data = useRealData
+     }
+ 
+     const response = await this.client.get(
+       `/stocks/${stockCode}/enhanced`,
+       { params }
+     )
+ 
+     return response.data
+   }
+ 
+   /**
+    * GET /recommended-stocks - Get recommended stocks with caching
+    */
+   async getRecommendedStocks(limit = 10, useRealData = true): Promise<any[]> {
+     // Check cache first for 24h offline support
+     const cacheKey = generateCacheKey('recommended-stocks', { limit, useRealData });
+     try {
+       const cached = recommendationCache.get<any[]>(cacheKey)
+       if (cached) {
+         console.log('[StockAPI] Using cached recommended stocks')
+         return cached
+       }
+     } catch (error) {
+       logCacheError(error as Error, {
+         operation: 'get',
+         key: cacheKey,
+         function: 'getRecommendedStocks'
+       })
+     }
+ 
+     try {
+       const params: Record<string, any> = { limit }
+       if (useRealData) {
+         params.use_real_data = useRealData
+       }
+ 
+       const response = await this.client.get<any>('/recommended-stocks', { params })
+       const responseData = response.data
+ 
+       // Handle different response formats
+       let recommendations: any[]
+       if (Array.isArray(responseData)) {
+         // Direct array response
+         recommendations = responseData
+       } else if (responseData && Array.isArray(responseData.stocks)) {
+         // Object with stocks array
+         recommendations = responseData.stocks
+       } else {
+         const error = new ValidationError('Invalid data type: expected array or object with stocks array in recommended stocks response')
+         logValidationError(error.message, {
+           function: 'getRecommendedStocks',
+           responseType: typeof responseData,
+           hasStocks: responseData?.stocks ? 'yes' : 'no'
+         })
+         throw error
+       }
+ 
+       // Cache with 24h TTL for offline support
+       try {
+         recommendationCache.set(cacheKey, recommendations, 24 * 60 * 60 * 1000)
+       } catch (error) {
+         logCacheError(error as Error, {
+           operation: 'set',
+           key: cacheKey,
+           function: 'getRecommendedStocks'
+         })
+       }
+ 
+       return recommendations
+     } catch (error) {
+       // Log prediction-related errors for monitoring
+       if (error instanceof StockApiError || error instanceof ValidationError) {
+         throw error
+       }
+       
+       errorLogger.logError({
+         message: `Failed to get recommended stocks: ${error instanceof Error ? error.message : 'Unknown error'}`,
+         category: ErrorCategory.PREDICTION,
+         severity: ErrorSeverity.HIGH,
+         context: {
+           function: 'getRecommendedStocks',
+           limit,
+           useRealData
+         },
+         error: error instanceof Error ? error : undefined
+       })
+       throw error
+     }
+   }
+ 
+   /**
+    * GET /trading-recommendations - Get trading recommendations with caching
+    */
+   async getTradingRecommendations(useRealData = true): Promise<any[]> {
+     // Check cache first
+     const cacheKey = generateCacheKey('trading-recommendations', { useRealData });
+     const cached = recommendationCache.get<any[]>(cacheKey)
+     if (cached) {
+       console.log('[StockAPI] Using cached trading recommendations')
+       return cached
+     }
+ 
+     const params: Record<string, any> = {}
+     if (useRealData) {
+       params.use_real_data = useRealData
+     }
+ 
+     const response = await this.client.get<any[]>('/trading-recommendations', { params })
+     const recommendations = response.data
+ 
+     // Validate response is array
+     if (!Array.isArray(recommendations)) {
+       throw new ValidationError('Invalid data type: expected array in trading recommendations response')
+     }
+ 
+     // Cache with 24h TTL for offline support  
+     recommendationCache.set(cacheKey, recommendations, 24 * 60 * 60 * 1000)
+ 
+     return recommendations
+   }
+ 
+   /**
+    * Adjust current price data to realistic values
+    */
+   private adjustCurrentPriceToRealistic(currentPriceData: CurrentPriceResponse): CurrentPriceResponse {
+     const stockCode = currentPriceData.stock_code
+     let realisticBasePrice: number
+     
+     // Set realistic prices based on stock code
+     switch (stockCode) {
+       case '7203': // Toyota
+         realisticBasePrice = 3500
+         break
+       case '6758': // Sony
+         realisticBasePrice = 11000
+         break
+       case '9984': // SoftBank
+         realisticBasePrice = 6000
+         break
+       case '9983': // Fast Retailing
+         realisticBasePrice = 85000
+         break
+       case '8306': // Mitsubishi UFJ
+         realisticBasePrice = 1200
+         break
+       default:
+         realisticBasePrice = 2500
+         break
+     }
+     
+     // Calculate realistic variation (±5%)
+     const variation = (Math.random() - 0.5) * 0.1 // -5% to +5%
+     const currentPrice = realisticBasePrice * (1 + variation)
+     const previousClose = realisticBasePrice * (1 + (Math.random() - 0.5) * 0.04) // ±2%
+     const priceChange = currentPrice - previousClose
+     const priceChangePct = (priceChange / previousClose) * 100
+     
+     const adjustedCurrentPrice = {
+       ...currentPriceData,
+       current_price: Math.round(currentPrice * 100) / 100,
+       previous_close: Math.round(previousClose * 100) / 100,
+       price_change: Math.round(priceChange * 100) / 100,
+       price_change_pct: Math.round(priceChangePct * 100) / 100,
+     }
+     
+     return adjustedCurrentPrice
+   }
+ 
+   /**
+    * Adjust mock price data to realistic values based on stock code
+    */
+   private adjustPriceToRealistic(stockData: StockData): StockData {
+     const stockCode = stockData.stock_code
+     let realisticBasePrice: number
+     let companyName: string
+     
+     // Set realistic prices based on stock code
+     switch (stockCode) {
+       case '7203': // Toyota
+         realisticBasePrice = 3500
+         companyName = 'トヨタ自動車株式会社'
+         break
+       case '6758': // Sony
+         realisticBasePrice = 11000
+         companyName = 'ソニーグループ株式会社'
+         break
+       case '9984': // SoftBank
+         realisticBasePrice = 6000
+         companyName = 'ソフトバンクグループ株式会社'
+         break
+       case '9983': // Fast Retailing
+         realisticBasePrice = 85000
+         companyName = '株式会社ファーストリテイリング'
+         break
+       case '8306': // Mitsubishi UFJ
+         realisticBasePrice = 1200
+         companyName = '株式会社三菱UFJフィナンシャル・グループ'
+         break
+       default:
+         realisticBasePrice = 2500 // Default realistic price
+         companyName = stockData.company_name
+         break
+     }
+     
+     // Calculate realistic variation (±5%)
+     const variation = (Math.random() - 0.5) * 0.1 // -5% to +5%
+     const currentPrice = realisticBasePrice * (1 + variation)
+     const previousClose = realisticBasePrice * (1 + (Math.random() - 0.5) * 0.04) // ±2%
+     const priceChange = currentPrice - previousClose
+     const priceChangePct = (priceChange / previousClose) * 100
+     
+     const adjustedData = {
+       ...stockData,
+       company_name: companyName,
+       current_price: Math.round(currentPrice * 100) / 100,
+       previous_close: Math.round(previousClose * 100) / 100,
+       price_change: Math.round(priceChange * 100) / 100,
+       price_change_pct: Math.round(priceChangePct * 100) / 100,
+       day_high: Math.round(currentPrice * 1.02 * 100) / 100,
+       day_low: Math.round(currentPrice * 0.98 * 100) / 100,
+       year_high: Math.round(realisticBasePrice * 1.3 * 100) / 100,
+       year_low: Math.round(realisticBasePrice * 0.7 * 100) / 100,
+       market_cap: currentPrice * 1000000000 // Simplified market cap
+     }
+     
+     return adjustedData
+   }
+ 
+   /**
+    * Clear all caches - useful for development and testing
++>>>>>>> origin/main
     */
    clearCache(): void {
 -    stockDataCache.clear()
 -    priceHistoryCache.clear()
 -    recommendationCache.clear()
 -    console.log('[StockAPI] All caches cleared')
 -  }
 +    console.log('Mock: Cache cleared')
 +  },
  
    /**
 -   * Get cache statistics for monitoring
 +   * Get cache statistics (mock implementation)
     */
 -  getCacheStats(): {
 -    stockData: any
 -    priceHistory: any
 -    recommendations: any
 -  } {
 +  getCacheStats(): any {
      return {
 -      stockData: stockDataCache.getStats(),
 -      priceHistory: priceHistoryCache.getStats(),
 -      recommendations: recommendationCache.getStats()
 +      stockData: { size: 0, hitRate: 0 },
 +      priceHistory: { size: 0, hitRate: 0 },
 +      recommendations: { size: 0, hitRate: 0 }
      }
    }
 -
 -  /**
 -   * Health check endpoint
 -   */
 -  async healthCheck(): Promise<{ status: string; timestamp: string }> {
 -    const response = await this.client.get<{ status: string; timestamp: string }>(
 -      '/health'
 -    )
 -
 -    return response.data
 -  }
 -}
 -
 -/**
 - * Default stock API client instance
 - * This is the primary export that components will use
 - */
 -export const stockApi = new StockApiClient()
 -
 -/**
 - * Create a custom stock API client with specific configuration
 - */
 -export function createStockApiClient(config: Partial<StockApiConfig>): StockApiClient {
 -  return new StockApiClient(config)
 -}
 -
 -/**
 - * Utility function to check if an error is a StockApiError
 - */
 -export function isStockApiError(error: unknown): error is StockApiError {
 -  return error instanceof StockApiError
 -}
 -
 -/**
 - * Utility function to check if an error is a ValidationError
 - */
 -export function isValidationError(error: unknown): error is ValidationError {
 -  return error instanceof ValidationError
 -}
 -
 -/**
 - * Format API errors for display to users
 - */
 -export function formatApiError(error: unknown): string {
 -  if (isStockApiError(error)) {
 -    return error.message
 -  } else if (isValidationError(error)) {
 -    return error.message
 -  } else if (error instanceof Error) {
 -    return error.message
 -  } else {
 -    return 'Unknown error occurred'
 -  }
  }
  
 -// Error classes are already exported above
 +export default stockApi
